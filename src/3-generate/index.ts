/**
 * Generation stage of the AAC pipeline
 *
 * @module generators
 * @description
 * Loads and executes generators to transform the validated ArchletteIR into
 * target DSL formats (Structurizr, PlantUML, Mermaid, etc.).
 *
 * The generation stage:
 * 1. Retrieves the validated IR from validation stage
 * 2. Loads generator modules from configuration
 * 3. Invokes each generator with the IR and configuration
 * 4. Collects generated DSL outputs
 * 5. Stores outputs in pipeline state for rendering stage
 *
 * Generators produce string output representing architecture diagrams
 * or documentation in specific DSL formats.
 *
 * @see {@link module:core/types-ir} for ArchletteIR schema
 * @see {@link module:core/stage-interfaces.ArchletteGenerator} for generator interface
 */

import type { PipelineContext, GeneratorOutput } from '../core/types.js';
import { loadGeneratorModule } from '../core/stage-module-loader.js';
import type { ResolvedAACConfig, ResolvedStageNode } from '../core/types-aac.js';
import { resolveArchlettePath, getCliDir, writeFile } from '../core/path-resolver.js';

/**
 * Execute the generation stage
 *
 * @param ctx - Pipeline context with configuration, logging, and validated IR
 * @throws May throw if a generator fails
 */
export async function run(ctx: PipelineContext): Promise<void> {
  ctx.log.info('Generate: transforming IR to DSL…');
  const config = ctx.config as ResolvedAACConfig;
  const generators: ResolvedStageNode[] = config?.generators || [];

  // Get the validated IR from validation stage (or aggregated if validation was skipped)
  const ir = ctx.state.validatedIR || ctx.state.aggregatedIR;
  if (!ir) {
    const errorMessage = [
      'Missing IR - extraction stage must run before generation.',
      '',
      'Troubleshooting:',
      '1. Ensure your config includes extractors and validators before generators:',
      '   extractors:',
      '     - use: builtin/basic-node',
      '   validators:',
      '     - use: builtin/base-validator',
      '   generators:',
      '     - use: builtin/structurizr',
      '',
      '2. Check if extraction and validation stages completed successfully',
      '3. Run with: archlette extract validate generate',
    ].join('\n');

    ctx.log.error(errorMessage);
    throw new Error('Missing IR');
  }

  const outputs: GeneratorOutput[] = [];

  // Process generators
  for (const node of generators) {
    try {
      const { entry, resolved } = await loadGeneratorModule(node.use);
      ctx.log.debug(`Loaded generator ${node.use} from ${resolved}`);
      ctx.log.debug(`Invoking generator ${node.use}`);
      const content = await entry(ir, node);
      ctx.log.debug(
        `Generator ${node.use} produced ${content.length} characters of output.`,
      );

      // Determine format from generator name
      const format = node.use.includes('structurizr')
        ? 'structurizr'
        : node.use.includes('plantuml')
          ? 'plantuml'
          : node.use.includes('mermaid')
            ? 'mermaid'
            : 'unknown';

      outputs.push({
        name: node.name || node.use,
        content,
        format,
      });

      ctx.log.info(`Generator ${node.use} completed.`);
    } catch (err) {
      ctx.log.error(`Generator ${node.use} failed:`, err);
      throw err;
    }
  }

  // Store generator outputs in pipeline state for rendering stage
  ctx.state.generatorOutputs = outputs;

  // Write DSL output to configured path
  if (outputs.length > 0) {
    try {
      const cliDir = getCliDir();
      ctx.log.debug(`Resolving DSL output destination from ${config.paths.dsl_out}`);
      const outputPath = resolveArchlettePath(config.paths.dsl_out, { cliDir });

      // If only one generator, write its content directly
      // If multiple generators, concatenate them with separators
      const content =
        outputs.length === 1
          ? outputs[0].content
          : outputs.map((o) => `# Generated by ${o.name}\n\n${o.content}`).join('\n\n');

      ctx.log.debug(`Writing DSL output (${content.length} chars) to ${outputPath}`);
      writeFile(outputPath, content);
      ctx.log.info(`✓ Wrote DSL output to ${outputPath}`);
    } catch (err) {
      ctx.log.error(`Failed to write DSL output to ${config.paths.dsl_out}:`, err);
      throw err;
    }
  }

  ctx.log.info(`Generate: completed ${generators.length} generator(s).`);
}
